
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.7.1'
import "https://deno.land/x/xhr@0.1.0/mod.ts"

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    // Initialize Supabase client
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') || '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || ''
    )

    // Parse request body
    const { avatarUrl, productImageUrl, userId } = await req.json()

    if (!avatarUrl || !productImageUrl || !userId) {
      return new Response(
        JSON.stringify({ error: 'Missing required parameters: avatarUrl, productImageUrl, or userId' }), 
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    console.log("Received try-on request:", { avatarUrl, productImageUrl })

    // Generate try-on image with Gemini
    const geminiResponse = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-pro-vision:generateContent', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-goog-api-key': Deno.env.get('GEMINI_API_KEY') || ''
      },
      body: JSON.stringify({
        contents: [{
          parts: [
            {
              text: `Create a realistic image of a person wearing the clothing item shown in this product image. Use the person's image as reference for their appearance. The final image should be a natural-looking photo of the person wearing the clothing item, with the same pose and background as the reference image of the person. The clothing should fit naturally and look realistic. Maintain the person's facial features exactly as they appear in the reference image.`
            },
            {
              inline_data: {
                mime_type: "image/jpeg",
                data: avatarUrl.startsWith('data:') 
                  ? avatarUrl.split(',')[1] 
                  : await fetch(avatarUrl).then(res => res.arrayBuffer()).then(buf => btoa(String.fromCharCode(...new Uint8Array(buf))))
              }
            },
            {
              inline_data: {
                mime_type: "image/jpeg",
                data: productImageUrl.startsWith('data:') 
                  ? productImageUrl.split(',')[1] 
                  : await fetch(productImageUrl).then(res => res.arrayBuffer()).then(buf => btoa(String.fromCharCode(...new Uint8Array(buf))))
              }
            }
          ]
        }],
        generationConfig: {
          temperature: 0.4,
          topK: 32,
          topP: 1,
          maxOutputTokens: 2048,
        }
      })
    });

    if (!geminiResponse.ok) {
      const errorText = await geminiResponse.text();
      let errorJson;
      
      try {
        errorJson = JSON.parse(errorText);
        console.error('Gemini API error (parsed):', errorJson);
      } catch (parseError) {
        console.error('Gemini API error (raw text):', errorText);
      }
      
      console.error('Gemini API HTTP status:', geminiResponse.status);
      console.error('Gemini API status text:', geminiResponse.statusText);
      
      // As a fallback for this demo, we'll just return the avatar image
      // In a production environment, you'd want to handle this more gracefully
      console.log("Using avatar as fallback due to Gemini API error");
      
      // Get the public URL for the avatar
      const { data: { publicUrl } } = supabase.storage
        .from('avatars')
        .getPublicUrl(`user-${userId}/avatar.png`)
      
      return new Response(
        JSON.stringify({ 
          tryOnImageUrl: publicUrl,
          isPlaceholder: true
        }), 
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }
    
    const geminiData = await geminiResponse.json();
    
    if (!geminiData.candidates || geminiData.candidates.length === 0) {
      console.error("No candidates returned from Gemini API");
      throw new Error("No image generated by Gemini");
    }
    
    // Extract image data from Gemini response
    let generatedImageUrl = null;
    for (const candidate of geminiData.candidates) {
      for (const part of candidate.content.parts) {
        if (part.inline_data && part.inline_data.mime_type.startsWith('image/')) {
          generatedImageUrl = `data:${part.inline_data.mime_type};base64,${part.inline_data.data}`;
          break;
        }
      }
      if (generatedImageUrl) break;
    }
    
    if (!generatedImageUrl) {
      console.error("No image found in Gemini response");
      throw new Error("No image returned by Gemini");
    }

    console.log("Generated image data received");

    // Convert data URL to blob for upload to Supabase
    const base64Data = generatedImageUrl.split(',')[1];
    const binaryData = atob(base64Data);
    const array = new Uint8Array(binaryData.length);
    for (let i = 0; i < binaryData.length; i++) {
      array[i] = binaryData.charCodeAt(i);
    }
    const imageBlob = new Blob([array], { type: 'image/png' });
    
    // Upload to Supabase storage
    const tryOnFileName = `try-on-${userId}-${Date.now()}.png`;

    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('avatars')
      .upload(`try-ons/${tryOnFileName}`, imageBlob, {
        contentType: 'image/png',
        upsert: true
      })

    if (uploadError) throw uploadError

    // Get the public URL for the uploaded try-on image
    const { data: { publicUrl } } = supabase.storage
      .from('avatars')
      .getPublicUrl(`try-ons/${tryOnFileName}`)

    console.log("Try-on image stored at:", publicUrl)

    return new Response(
      JSON.stringify({ 
        tryOnImageUrl: publicUrl 
      }), 
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  } catch (error) {
    console.error('Try-on generation error:', error)
    return new Response(
      JSON.stringify({ error: error.message }), 
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }
})
