
import { serve } from "https://deno.land/std@0.168.0/http/server.ts"
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.7.1'
import "https://deno.land/x/xhr@0.1.0/mod.ts"

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    // Parse request body
    const { avatarUrl, productImageUrl, userId, responseType = 'image/png', includeImageResponse = true } = await req.json()

    if (!avatarUrl || !productImageUrl || !userId) {
      return new Response(
        JSON.stringify({ error: 'Missing avatarUrl, productImageUrl, or userId' }), 
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    console.log('Processing try-on generation for user:', userId)
    console.log('Avatar URL:', avatarUrl)
    console.log('Product URL:', productImageUrl)
    console.log('Response type requested:', responseType)

    // Initialize Supabase client
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') || '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || ''
    )

    // Download avatar image
    const avatarResponse = await fetch(avatarUrl)
    if (!avatarResponse.ok) {
      throw new Error(`Failed to download avatar image: ${avatarResponse.status}`)
    }
    const avatarBlob = await avatarResponse.blob()
    const avatarBuffer = await avatarBlob.arrayBuffer()
    const avatarBytes = new Uint8Array(avatarBuffer)
    
    console.log('Avatar image downloaded')

    // Download product image
    const productResponse = await fetch(productImageUrl)
    if (!productResponse.ok) {
      throw new Error(`Failed to download product image: ${productResponse.status}`)
    }
    const productBlob = await productResponse.blob()
    const productBuffer = await productBlob.arrayBuffer()
    const productBytes = new Uint8Array(productBuffer)
    
    console.log('Product image downloaded')

    let tryOnImageBase64 = null
    let isPlaceholder = false

    try {
      // Get Stability API key
      const STABILITY_API_KEY = Deno.env.get('STABILITY_API_KEY')
      if (!STABILITY_API_KEY) {
        throw new Error('STABILITY_API_KEY is not set')
      }

      console.log('Using Stability AI for image generation')
      
      // Create form data with avatar and product images
      const formData = new FormData()
      formData.append('init_image', new Blob([avatarBytes], { type: 'image/jpeg' }))
      formData.append('image_strength', '0.35') // Control how much influence the init image has
      formData.append('style_preset', 'photographic')
      formData.append('cfg_scale', '7')
      formData.append('samples', '1')
      formData.append('steps', '30')
      
      // Add text prompt to reflect what we want
      formData.append('text_prompts[0][text]', `Person wearing the clothing from this product image. Realistic, photographic quality. Professional fashion photography.`)
      formData.append('text_prompts[0][weight]', '1')
      
      // Add negative prompts
      formData.append('text_prompts[1][text]', 'blurry, bad quality, distorted, deformed, disfigured, unrealistic, cartoon')
      formData.append('text_prompts[1][weight]', '-1')

      // Call Stability AI API
      const stabilityResponse = await fetch(
        'https://api.stability.ai/v1/generation/stable-diffusion-xl-1024-v1-0/image-to-image',
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${STABILITY_API_KEY}`,
            // No content-type as FormData sets it with boundary
          },
          body: formData
        }
      )

      if (!stabilityResponse.ok) {
        const errorText = await stabilityResponse.text()
        console.error('Error response from Stability API:', errorText)
        throw new Error(`Stability API returned status ${stabilityResponse.status}: ${errorText}`)
      }
      
      const stabilityData = await stabilityResponse.json()
      console.log('Stability API response received')
      
      // Parse the response to extract the generated image
      if (stabilityData.artifacts && stabilityData.artifacts.length > 0) {
        const generatedImage = stabilityData.artifacts[0]
        tryOnImageBase64 = generatedImage.base64
        
        console.log('Successfully retrieved generated image from Stability AI')
      } else {
        console.error('No images found in Stability response:', stabilityData)
        throw new Error('No images generated by Stability AI')
      }
      
    } catch (aiError) {
      console.error('Error from Stability AI:', aiError)
      // Fall back to using the avatar as a placeholder
      console.log('Falling back to avatar as placeholder')
      
      // Convert avatar to base64
      const avatarBase64 = btoa(String.fromCharCode(...avatarBytes))
      tryOnImageBase64 = avatarBase64
      isPlaceholder = true
      
      // Return early with the placeholder
      const userFolder = `try-on/${userId}`
      const fileName = `${Date.now()}.${responseType.split('/')[1]}`
      const filePath = `${userFolder}/${fileName}`
      
      // Convert base64 to Uint8Array for upload
      const binaryString = atob(tryOnImageBase64)
      const len = binaryString.length
      const bytes = new Uint8Array(len)
      for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i)
      }
      
      // Upload the generated image (or avatar as fallback)
      const { data: uploadData, error: uploadError } = await supabase
        .storage
        .from('avatars')  // Using the avatars bucket for try-on images as well
        .upload(filePath, bytes, {
          contentType: responseType,
          upsert: true
        })
      
      if (uploadError) {
        console.error('Error uploading try-on image:', uploadError)
        throw uploadError
      }
      
      // Get the public URL for the uploaded image
      const { data: { publicUrl } } = supabase.storage
        .from('avatars')
        .getPublicUrl(filePath)
      
      return new Response(
        JSON.stringify({ 
          tryOnImageUrl: publicUrl,
          isPlaceholder: true,
          message: "Used avatar as placeholder due to AI API error"
        }), 
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      )
    }

    // Create the directory path for storing the try-on image
    const userFolder = `try-on/${userId}`
    const fileName = `${Date.now()}.${responseType.split('/')[1]}`
    const filePath = `${userFolder}/${fileName}`
    
    // Convert base64 to Uint8Array for upload
    const binaryString = atob(tryOnImageBase64)
    const len = binaryString.length
    const bytes = new Uint8Array(len)
    for (let i = 0; i < len; i++) {
      bytes[i] = binaryString.charCodeAt(i)
    }
    
    // Upload the generated image
    const { data: uploadData, error: uploadError } = await supabase
      .storage
      .from('avatars')  // Using the avatars bucket for try-on images as well
      .upload(filePath, bytes, {
        contentType: responseType,
        upsert: true
      })
    
    if (uploadError) {
      console.error('Error uploading try-on image:', uploadError)
      throw uploadError
    }
    
    // Get the public URL for the uploaded image
    const { data: { publicUrl } } = supabase.storage
      .from('avatars')
      .getPublicUrl(filePath)
    
    console.log('Try-on image stored at:', publicUrl)
    
    return new Response(
      JSON.stringify({ 
        tryOnImageUrl: publicUrl,
        isPlaceholder: isPlaceholder
      }), 
      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  } catch (error) {
    console.error('Error during try-on generation:', error)
    return new Response(
      JSON.stringify({ error: error.message || 'An unexpected error occurred' }), 
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    )
  }
})
